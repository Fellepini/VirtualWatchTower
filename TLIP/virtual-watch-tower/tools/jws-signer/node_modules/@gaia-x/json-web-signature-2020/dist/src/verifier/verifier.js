"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Verifier = void 0;
const jose_1 = require("jose");
const luxon_1 = require("luxon");
const did_resolver_1 = require("../resolver/did.resolver");
const malformed_proof_exception_1 = require("./exception/malformed-proof.exception");
const signature_validation_exception_1 = require("./exception/signature-validation.exception");
const unresolvable_verification_method_exception_1 = require("./exception/unresolvable-verification-method.exception");
/**
 * This class' responsibility is to ensure that verifiable credentials are untampered between their creation/signing
 * and their usage through this library.
 */
class Verifier {
    constructor(hasher, options) {
        var _a;
        this.hasher = hasher;
        this.didResolver = (_a = options === null || options === void 0 ? void 0 : options.didResolver) !== null && _a !== void 0 ? _a : new did_resolver_1.DidResolver();
    }
    /**
     * Verifies that the verifiable credential and its proof match the given JWS.
     *
     * @param verifiableCredential the {@link VerifiableCredential} to validate
     *
     * @throws MalformedProofException when the proof is malformed, more details are given in the exception's message
     * @throws UnresolvableVerificationMethodException when the verification method specified in the proof can't be resolved to collect the issuer's public key
     * @throws SignatureValidationException when the signature given in the proof does not match the verifiable credential's content, this usually happens when the verifiable credential has been tampered
     */
    async verify(verifiableCredential) {
        // Cloning the input verifiable credential avoids modifying the calling method's object
        const { proof, document } = this.separateProofAndDocument(verifiableCredential);
        const jws = structuredClone(proof.jws);
        const publicKey = await this.extractPublicKey(proof);
        const hash = await this.hasher.hash(document, proof);
        const jwsParts = jws.split('.');
        try {
            await (0, jose_1.flattenedVerify)({ protected: jwsParts[0], payload: hash, signature: jwsParts[2] }, publicKey);
        }
        catch (e) {
            throw new signature_validation_exception_1.SignatureValidationException(verifiableCredential.id);
        }
    }
    separateProofAndDocument(verifiableCredential) {
        // Cloning the input verifiable credential avoids modifying the calling method's object
        const _a = structuredClone(verifiableCredential), { proof } = _a, document = __rest(_a, ["proof"]);
        if (proof.type != 'JsonWebSignature2020') {
            throw new malformed_proof_exception_1.MalformedProofException(`${proof.type} proof type is not supported`);
        }
        const parsedDate = luxon_1.DateTime.fromISO(proof.created);
        if (proof.created && !parsedDate.isValid) {
            throw new malformed_proof_exception_1.MalformedProofException(`Please provide a valid proof 'created' attribute, ${proof.created} is invalid`);
        }
        if (!proof.jws) {
            throw new malformed_proof_exception_1.MalformedProofException(`The 'jws' attribute is missing in the proof, this isn't a valid verifiable credential`);
        }
        return { proof, document };
    }
    async extractPublicKey(proof) {
        var _a, _b;
        const [did, verificationMethodId] = proof.verificationMethod.split('#');
        const didDocument = await this.didResolver.resolve(did);
        let verificationMethod = (_a = didDocument.verificationMethod) === null || _a === void 0 ? void 0 : _a.find(v => v.id === proof.verificationMethod);
        if (!verificationMethod) {
            verificationMethod = (_b = didDocument.publicKey) === null || _b === void 0 ? void 0 : _b.find(p => p.id === `#${verificationMethodId}`);
        }
        if (!verificationMethod) {
            throw new unresolvable_verification_method_exception_1.UnresolvableVerificationMethodException(proof.verificationMethod);
        }
        const jwk = verificationMethod.publicKeyJwk;
        return await (0, jose_1.importJWK)(jwk);
    }
}
exports.Verifier = Verifier;
//# sourceMappingURL=verifier.js.map