import { Hasher } from '../hasher/hasher';
import { VerifiableCredential } from '../model/verifiable-credential.model';
import { VerifierOptions } from '../options/verifier.options';
/**
 * This class' responsibility is to ensure that verifiable credentials are untampered between their creation/signing
 * and their usage through this library.
 */
export declare abstract class Verifier {
    private readonly didResolver;
    private readonly hasher;
    protected constructor(hasher: Hasher, options?: VerifierOptions);
    /**
     * Verifies that the verifiable credential and its proof match the given JWS.
     *
     * @param verifiableCredential the {@link VerifiableCredential} to validate
     *
     * @throws MalformedProofException when the proof is malformed, more details are given in the exception's message
     * @throws UnresolvableVerificationMethodException when the verification method specified in the proof can't be resolved to collect the issuer's public key
     * @throws SignatureValidationException when the signature given in the proof does not match the verifiable credential's content, this usually happens when the verifiable credential has been tampered
     */
    verify(verifiableCredential: VerifiableCredential): Promise<void>;
    private separateProofAndDocument;
    private extractPublicKey;
}
